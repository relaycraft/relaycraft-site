---
title: "做一个不妥协的抓包工具：RelayCraft 诞生的故事"
description: "作为一个在软件行业摸爬滚打十几年的开发者，我用过无数的工具。这篇文章聊聊为什么我要亲手打造 RelayCraft，以及我对理想调试工具的理解。"
pubDate: 2026-02-21
author: "RelayCraft Team"
lang: zh
tags: ["behind-the-scenes", "vision", "design"]
featured: true
---

作为一个在软件行业摸爬滚打了十几年的开发者，我用过无数的工具。在 2019 年后由产品经理转向软件开发并深耕前端领域以来，我的日常工作始终离不开一个环节——**网络抓包**。

如果你和我一样，那你一定经历过这样崩溃的时刻：

- **用 Charles 时**：为了配置一个 `Map Local`，你不得不点开 5 层对话框，在密密麻麻的列表里找到那个接口，然后祈祷它的 Java 进程不要突然吃掉 2GB 内存导致卡死。
- **用 Whistle 时**：虽然它的插件生态很强大，但当你写错了一行正则规则，界面不会有任何报错提示，你只能盯着没生效的请求发呆半天，最后发现是转义字符少写了一个斜杠。
- **用 Fiddler 时**：那充满年代感的 UI 让你觉得自己还在 Windows XP 时代，想要修改一个响应体，却要在脚本编辑器里翻找半天的 API 文档。

这种时候，我总会想：**都 2025 年了，我们的调试工具为什么不能更"性感"一点？为什么不能既拥有 Whistle 的灵活，又有 IDE 般的优雅体验？**

## 极致美学，也是生产力

在开发 RelayCraft 时，我一直坚持一个也许听起来有点"任性"的理念：**工具的美学设计，本身就是生产力**。

很多人觉得工具只要能用就行，界面丑点无所谓。但我不同意。作为开发者，我们每天要处理海量的信息。一个好的工具，应该通过**色彩**、**排版**和**交互**，帮你快速过滤噪音，直达重点。

RelayCraft 的界面设计远超"暗色模式"的范畴——我们追求的是一套**完整的设计语言系统**：

- **全方位主题定制**：支持换肤、换色、换字体，甚至可以注入自定义 CSS 片段。你可以把它打造成 VS Code 风格，也可以调成 Xcode 风格，或者完全属于你自己的风格。
- **语义化色彩系统**：每一个状态码、每一种请求类型（GET/POST/OPTIONS）都有它该有的颜色和标签。一眼扫过去，通过色彩你就能知道系统的健康状况。
- **原生级交互体验**：macOS 原生质感的动画、流畅的滚动、精确的焦点管理，让每一次点击都成为一种享受。

这不是为了"好看"，而是为了让你的眼睛和大脑在长时间工作中保持最佳状态。

## 规则，应该是声明式的代码

在开发 RelayCraft 的过程中，**规则引擎**是我思考最多、打磨最久的模块。

传统的代理工具，规则往往是"配置"，藏在深不见底的菜单里，或者是一堆难以维护的脚本。但在 RelayCraft 里，我重新定义了规则：

### 1. 规则 = 匹配 + 动作

这是整个规则系统的基石。无论多么复杂的场景，本质上都在回答两个问题：

1. **匹配（Match）**：这个请求符合什么条件？（URL、Header、Method...）
2. **动作（Action）**：符合条件后要做什么？（Mock、重定向、修改、阻断...）

```yaml
# 一条规则的核心结构，简单到无需解释
match:
  request:
    - type: url
      matchType: regex
      value: "api\\.example\\.com/v1/(\\w+)"
actions:
  - type: map_remote
    targetUrl: "api-staging.example.com/v1/$1"
```

这种结构带来了**可预测性**。你不需要记忆不同的菜单位置，所有规则逻辑都是统一的。

### 2. 文件即规则，Git 友好

我选择了 **YAML** 作为规则的存储格式，并且直接映射到文件系统。这意味着什么？意味着你的抓包规则可以像代码一样被 **Git 版本控制**。

- **团队协作**：把 `rules/` 目录推到仓库，团队成员 pull 下来即可共享一套 Mock 规则。
- **历史追溯**：谁在什么时候修改了哪个接口的 Mock 数据，Git log 一清二楚。
- **IDE 支持**：你甚至可以直接在 VS Code 里编辑规则，享受代码补全和格式化。

### 3. 从 GUI 到代码的平滑曲线

RelayCraft 支持图形化配置，也支持直接编辑 YAML，甚至支持 **Python 脚本**。

- **新手**：可以在界面上点选"Map Local"，可视化配置。
- **高手**：可以直接手写 YAML，甚至利用 **正则捕获组反查**（如 `$1`, `$2`）来处理复杂路径，或者用 **JSONPath** 精准修改响应体中的某个字段，而无需重写整个 JSON。
- **极客**：当规则无法满足时，一键切换到 Python 脚本模式，获得无限的能力扩展。

### 4. 消灭"正则焦虑"

最让我自豪的一个细节是 **实时匹配测试**。

在传统工具里，写正则像"抽奖"。在 RelayCraft 的规则编辑器里，你输入一个测试 URL，系统会立即告诉你：

```text
URL: https://api.example.com/v1/users/123
✅ 匹配成功
├── host: api.example.com ✓
└── path: /v1/users/* ✓
```

再也不用担心"规则为什么不生效"的困惑。

## AI，不只是噱头

市面上很多工具都在加 AI，但很多只是为了加而加。在 RelayCraft 里，AI 是深度融合的伙伴。

- **智能正则生成**：你不需要成为正则专家。只需告诉 AI："匹配所有以 .png 结尾的图片请求"，它会自动生成严谨的正则表达式。
- **上下文感知调试**：当你遇到一个不知所云的 500 报错时，不需要切出去问 ChatGPT。直接在 RelayCraft 里选中该请求问 AI："这个请求为什么挂了？"它会结合请求头、响应体和日志给你答案。

这才是 AI 该有的样子——它应该像你的结对编程伙伴，而不是一个外挂的聊天机器人。

## 技术选型：站在巨人的肩膀上

RelayCraft 的底层使用了 **mitmproxy** —— 这是一个非常成熟、强大的 Python 代理库，也是行业标准。

选择它作为起步，让我们能够快速构建出稳定、可靠的核心功能，把精力集中在打磨极致的 UI/UX、规则引擎和 AI 交互上。

但这只是开始。

我们已经在开发 **relay-core** —— RelayCraft 的下一代代理引擎，完全使用 **Rust** 编写。Rust 的引入将让 RelayCraft 在处理高并发流量（目标 100W+ 请求不卡）时更加轻盈、丝滑。这是我们对未来的承诺。

## 我们的愿景：不止是抓包工具

RelayCraft 的终极目标，不是做另一个 Charles 或 Whistle 的替代品。

**我们要打造的是一个全功能的流量管理与开发协作平台。**

想象一下这样的场景：

- 前端开发者可以用它快速 Mock 接口，无需等待后端完成
- 测试人员可以用它模拟弱网、延迟、错误响应，无需搭建复杂环境
- 后端开发者可以用它分析线上流量，定位性能瓶颈
- 团队可以把规则配置纳入 Git 工作流，实现环境配置的版本化管理

从**个人调试工具**，到**团队协作风控台**，再到**企业级流量治理平台** —— 这是 RelayCraft 的进化路线。

## 写在最后

RelayCraft 是我送给自己，也是送给所有追求品质的开发者的一份礼物。

它可能还不够完美，但它足够真诚。它承载了我对"高效、优雅、现代"开发工具的所有理解。它不想做一个大而全的瑞士军刀，只想做你手边那把最顺手的手术刀。

如果你也厌倦了千篇一律的旧工具，厌倦了 Java 进程的卡顿和复杂配置的折磨，不妨来试试 RelayCraft。哪怕只是为了体验一次"实时正则测试"的爽快感，或者自定义一套完全属于你自己的界面主题，我相信你也会觉得不虚此行。

**让我们一起，把调试这件枯燥的小事，变得稍微有趣一点。**

---

- ⭐ **GitHub**: [github.com/relaycraft/relaycraft](https://github.com/relaycraft/relaycraft)
- 🌐 **官网**: [relaycraft.dev](https://relaycraft.dev)
- 🐦 **关注动态**: [@relaycraft_app](https://twitter.com/relaycraft_app)
